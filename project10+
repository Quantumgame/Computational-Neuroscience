import numpy as np
import pylab as pl

tau=0.001#s
binsize=0.001#s
dt=0.001#s
T=1.#s
N=3#number of neuron
gE=0.015
gI=-0.075
y0=10#Hz
n=int(T/binsize)


rI = N/5 
rE = N - rI

network = np.zeros((N,N))
p = 0.3 #connection probability

#creation of network with p probability
for i in range(0,N):
    for j in range(0,N):
        random = np.random.uniform(0.,1.)
        if random < p:
            network[j,i] = 1

network[:,0:rI] = network[:,0:rI] *gI #inhibitory neurons
network[:,-rE:] = network[:,-rE:] * gE #excitatory neurons 


def poisson(rate,sim_time): 
    '''creation of poisson input for a single neuron''' 
    time = 0.
    events = np.array([])
    while (time<sim_time):
        event= -np.log(np.random.rand())*(1./rate)
        time+=event
        events = np.append(events,time)
    return events

def spike_train():
    spikes_train = np.zeros((N,n))
    inputtimes=np.zeros((N,n))
    for i in range(0,N):
        A=poisson(10.,T)#whether should we take out the value larger than 1s?
        spikes_train[i]=np.histogram(A,np.arange(0,T+binsize,binsize))[0] #number of spikes 
        inputtimes[i]=np.histogram(A,np.arange(0,T+binsize,binsize))[1] #times of spikes
    return spikes_train,inputtimes

def allinputs(neuron):
    ''' returns the weights of the input for a given 'neuron' '''
    g = network[neuron]
    return g

def outputrate(neuron):
    '''neuronal model. returns output spike rate given the poisson input'''
    y=np.zeros(n)
    y[0]=0
    C=np.exp(-binsize/tau)
    g = allinputs(neuron) # the weights of the inputs for target 'neuron'
    for t in range(0,n-1):
        #G is the sum of the weighted inputs for each time step
        for i in range(0,N):
            G = np.sum(spike_train()[0][:,i] * g)
            y[t+1]= C*y[t]+G   
    return y+y0


def alloutputrates():
    '''returns the output spike rate off all N'''
    allrates = np.zeros((N,n))
    for i in range(0,N):
        allrates[i] = outputrate(i)
    return allrates
 
def neuronfireP(neuron):
    '''generates a probability given a spike rate of a single neuron'''
    P=np.zeros(n)
    c=outputrate(neuron)
    P=1-np.exp(-1*c*dt)
    return P

#k=neuronfireP(gI)
#pl.plot(k)
#pl.show()
       
def neuronspikes(neuron):
    '''generates a spike train given the probability calculates in 'neuronfireP' of a single neuron '''
    P=neuronfireP(neuron)
    single_train=np.zeros(len(P))
    for i in range(0,len(P)):
        ran=np.random.uniform(low=0.0,high=1.0)
        if P[i]<=ran:
            single_train[i]=0
        else:
            single_train[i]=1
    return single_train

def allneuronsspikes():
    '''generates all the spike trains '''
    allspikes = np.zeros((N,n))
    for i in range(0,N):
        allspikes[i] = neuronspikes(i)
    return allspikes

def make_rasta_plot():
    pl.figure('Rastah plat oh jah')
    for idx in range(0,N):      
        x = allneuronsspikes()[idx,:]
        y = np.ones(len(x))*(idx+1)
        pl.plot(x,y,'o')
        pl.title('Raster Plot')
        pl.xlabel('Time')
        pl.ylabel('Neuron Index')
    #pl.show()
    return len(y)
